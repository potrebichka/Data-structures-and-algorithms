## 1-1. Evacuating People.
*An algorithm for finding maximum flow in a network to determine how fast people can be evacuated from the given city.*

**Input:** The first line of the input contains integers n and m — the number of cities and the number of roads respectively. Each of the next m lines contains three integers u, v and c describing a particular road — start of the road, end of the road and the number of people that can be transported through this road in one hour. u and v are the 1-based indices of the corresponding cities.
The city from which people are evacuating is the city number 1, and the capital city is the city number n.

**Output:** The maximum number of people that can be evacuated from the city nu,ber 1 each hour.

## 1-2. Assigning Airline Crews to Flights.
*The airline offers a bunch of flights and has a set of crews that can work on those flights. However, the flights are starting in different cities and at different times, so only some of the crews are able to work on a particular flight. You are given the pairs of flights and associated crews that can work on those flights. You need to assign crews to as many flights as possible and output all the assignments.* An Algorithm for finding maximum matching in bipartite graph to assign airline crews to flights in the most efficient way.

**Input:** The first line of the input contains integers n and m — the number of flights and the number of crews respectively. Each of the next n lines contains m binary integers (0 or 1). If the j-th integer in the i-th line is 1, then the crew number j can work on the flight number i, and if it is 0, then it cannot.

**Output**: Output n integers — for each flight, output the 1-based index of the crew assigned to this flight. If no crew is assigned to a flight, output −1 as the index of the crew corresponding to it. All the positive indices in the output must be between 1 and m, and they must be pairwise different, but you can output any number of −1’s. If there are several assignments with the maximum possible number of flights having a crew assigned, output any of them.

## 1-3. Stock Charts.
*Find the most compact way of visualising stock price data using charts.*
You’re in the middle of writing your newspaper’s end-of-year economics summary, and you’ve decided that you want to show a number of charts to demonstrate how different stocks have performed over the course of the last year. You’ve already decided that you want to show the price of n different stocks, all at the same k points of the year. A simple chart of one stock’s price would draw lines between the points (0, price_0),(1, price_1), . . . ,(k − 1, price_k−1), where price_i is the price of the stock at the i-th point in time. In order to save space, you have invented the concept of an overlaid chart. An overlaid chart is the
combination of one or more simple charts, and shows the prices of multiple stocks (simply drawing a line for each one). In order to avoid confusion between the stocks shown in a chart, the lines in an overlaid chart may not cross or touch.
Given a list of n stocks’ prices at each of k time points, determine the minimum number of overlaid charts you need to show all of the stocks’ prices

**Input:** The first line of the input contains two integers n and k — the number of stocks and the number of points in the year which are common for all of them. Each of the next n lines contains k integers. The i-th of those n lines contains the prices of the i-th stock at the corresponding k points in the year.

**Output:**The minimum number of overlaid charts to visualize all the stock price data you have.

## 2-1. Ingfer Energy Values of Ingredients
*Apply Gaussian Elimination to infer the energy values of ingredients given a restaurant menu with calorie counts and ingredient lists provided for each item.
You’re looking into a restaurant menu which shows for each dish the list of ingredients with amounts and the estimated total energy value in calories. You would like to find out the energy values of individual ingredients (then you will be able to estimate the total energy values of your favorite dishes).*

**Input:** The first line of the input contains an integer n — the number of dishes in the menu, and it happens so that the number of different ingredients is the same. Each of the next n lines contains description a_1, a_2, . . . , a_n, E of a single menu item. a_i is the amount of i-th ingredient in the dish, and E is the estimated total energy value of the dish. If the ingredient is not used in the dish, the amount will be specified as a_i = 0; beware that although the amount of any ingredient in any real menu would be positive, we will test that your algorithm works even for negative amounts a_i < 0.

**Output**: n real numbers — for each ingredient, what is its energy value. These numbers can be non-integer, so output them with at least 3 digits after the decimal point.

## 2-2. Optimal Diet Problem
*Implement an algorithm for solving linear programming with only a few inequalities and apply it to determine the optimal diet.*

**Input:** The first line of the input contains integers n and m — the number of restrictions on your diet and the number of all available dishes and drinks respectively. The next n + 1 lines contain the coefficients of the linear inequalities in the standard form Ax ≤ b, where x = amount is the vector of length m with amounts of each ingredient, A is the n × m matrix with coefficients of inequalities and b is the vector with the right-hand side of each inequality. Specifically, i-th of the next n lines contains m integers A_i1, A_i2, . . . , A_im, and the next line after those n contains n integers b_1, b_2, . . . , b_n. These lines describe n inequalities of the form A_i1 · amount1 + A_i2 · amount2 + · · · + A_im · amount_m ≤ b_i. The last line of the input contains m integers — the pleasure for consuming one item of each dish and drink pleasure_1, pleasure_2, . . . , pleasure_m.

**Output:** If there is no diet that satisfies all the restrictions, output “No solution” (without quotes). If you can get as much pleasure as you want despite all the restrictions, output “Infinity” (without quotes). If the maximum possible total pleasure is bounded, output two lines. On the first line, output “Bounded solution” (without quotes). On the second line, output m real numbers — the optimal amounts for each dish and drink. Output all the numbers with at least 15 digits after the decimal point.

## 3-1. Assign Frequencies to the Cells of a GSM Network.
*This is equivalent to a classical graph coloring problem: in other words, you are given a graph, and you need to color its vertices into 3 different colors, so that any two vertices connected by an edge need to be of different colors. Colors correspond to frequencies, vertices correspond to cells, and edges connect neighboring cells. Graph coloring is an NP-complete problem, so we don’t currently know an efficient solution to it, and you need to reduce it to an instance of SAT problem which, although it is NP-complete, can often be solved efficiently in practice using special programs called SAT-solvers.*

**Input:** The first line of the input contains integers n and m — the number of vertices and edges in the graph. The vertices are numbered from 1 through n. Each of the next m lines contains two integers u and v — the numbers of vertices connected by an edge. It is guaranteed that a vertex cannot be connected to itself by an edge.

**Output**: You need to output a boolean formula in the conjunctive normal form (CNF) in a specific format. If it is possible to color the vertices of the input graph in 3 colors such that any two vertices connected by an edge are of different colors, the formula must be satisfiable. Otherwise, the formula must be unsatisfiable. The number of variables in the formula must be at least 1 and at most 3000. The number of clauses must be at least 1 and at most 5000. On the first line, output integers c and v — the number of clauses in the formula and the number of variables respectively. On each of the next c lines, output a description of a single clause. Each clause has a form (x_4 OR x_1 OR x_8). For a clause with k terms (in the example, k = 3 for x_4, x_1 and x_8), output first those k terms and then number 0 in the end (in the example, output “4 − 1 8 0”). Output each term as integer number. Output variables x_1, x_2, . . . , x_v as numbers 1, 2, . . . , v respectively. Output 3 negations of variables x_1, x_2, . . . , x_v as numbers −1, −2, . . . , −v respectively. Each number other than the last one in each line must be a non-zero integer between −v and v where v is the total number of variables specified in the first line of the output. Ensure that 1 ≤ c ≤ 5000 and 1 ≤ v ≤ 3000. If there are many different formulas that satisfy the requirements above, you can output any one of them.

## 3-2. Cleaning the Apartment.
*You’ve just had a huge party in your parents’ house, and they are returning tomorrow. You need to not only clean the apartment, but leave no trace of the party. To do that, you need to clean all the rooms in some order. After finishing a thorough cleaning of some room, you cannot return to it anymore: you are afraid you’ll ruin everything accidentally and will have to start over. So, you need to
move from room to room, visit each room exactly once and clean it. You can only move from a room to the neighboring rooms. You want to determine whether this is possible at all. This can be reduced to a classic Hamiltonian Path problem: given a graph, determine whether there is a route visiting each vertex exactly once. Rooms are vertices of the graph, and neighboring rooms are connected by edges. Hamiltonian Path problem is NP-complete, so we don’t know an efficient algorithm to solve it. You need to reduce it to SAT, so that it can be solved efficiently by a SAT-solver.*

**Input:** The first line contains two integers n and m — the number of rooms and the number of corridors connecting the rooms respectively. Each of the next m lines contains two integers u and v describing the corridor going from room u to room v. The corridors are two-way, that is, you can go both from u to v and from v to u. No two corridors have a common part, that is, every corridor only allows you to go from one room to one other room. Of course, no corridor connects a room to itself. Note that a corridor from u to v can be listed several times, and there can be listed both a corridor from u to v and a corridor from v to u.

**Output:** You need to output a boolean formula in the CNF form in a specific format. If it is possible to go through all the rooms and visit each one exactly once to clean it, the formula must be satisfiable. Otherwise, the formula must be unsatisfiable. The sum of the numbers of variables used in each clause of the formula must not exceed 120 000. On the first line, output integers c and v — the number of clauses in the formula and the number of variables respectively. On each of the next c lines, output a description of a single clause. Each clause has a form (x_4 OR x_1 OR x_8). For a clause with k terms (in the example, k = 3 for x_4, x_1 and x_8), output first those k terms and then number 0 in the end (in the example, output “4 − 1 8 0”). Output each term as integer number. Output variables x_1, x_2, . . . , x_v as numbers 1, 2, . . . , v respectively. Output negations of variables x_1, x_2, . . . , x_v as numbers −1, −2, . . . , −v respectively. Each number other than the last one in each line must be a non-zero integer between −v and v where v is the total number of variables specified in the first line of the output. Ensure that the total number of non-zero integers in the c lines describing the clauses is at most 120 000.

## 3-3. Advertisement Budget Allocation.
*In this programming assignment, you’ll work for a big company that uses advertising to promote itself. You will need to determine whether it is possible to allocate advertising budget and satisfy all the constraints. You will learn how to reduce this problem to a particular type of Integer Linear Programming problem. Then you will design and implement an efficient algorithm to reduce this type of Integer Linear Programming to SAT.*


Task. The marketing department of your big company has many subdepartments which control advertising on TV, radio, web search, contextual advertising, mobile advertising, etc. Each of them has prepared their advertising campaign plan, and of course you don’t have enough budget to cover all of their proposals. You don’t have enough time to go thoroughly through each subdepartment’s proposals and cut them, because you need to set the budget for the next year tomorrow. You decide that you will either approve or decline each of the proposals as a whole. There is a bunch of constraints you face. For example, your total advertising budget is limited. Also, you have some contracts with advertising agencies for some of the advertisement types that oblige you to spend at least some fixed budget on that kind of advertising, or you’ll see huge penalties, so you’d better spend it. Also, there are different company policies that can be of the form that you spend at least 10% of your total advertising spend on mobile advertising to promote yourself in this new channel, or that you spend at least $1M a month on TV advertisement, so that people always remember your brand. All of these constraints can be rewritten as an Integer Linear Programming: for each subdepartment i, denote by x_i boolean variable that corresponds to whether you will accept or decline the proposal of that subdepartment. Then each constraint can be written as a linear inequality.
For example, *E*(n, i=1) *spend_i* * *x_i* ≤ TotalBudget is the inequality to ensure your total budget is enough to accept all the selected proposals. And *E*(n, i=1) *spend_i* · *x_i* ≤ 10 · *mobile* corresponds to the fact that mobile advertisement budget is at least 10% of the total spending. You will be given the final Integer Linear Programming problem in the input, and you will need to reduce it to SAT. It is guaranteed that there will be at most 3 different variables with non-zero coefficients in each inequality of this Integer Linear Programming problem.

**Input:** The first line contains two integers n and m — the number of inequalities and the number of variables. The next *n* lines contain the description of *n*×*m* matrix *A* with coefficients of inequalities (each of the *n* lines contains *m* integers, and at most 3 of them are non-zero), and the last line contains the description of the vector *b* (*n* integers) for the system of inequalities *Ax* ≤ *b*. You need to determine whether there exists a binary vector *x* satisfying all those inequalities.

**Output:** You need to output a boolean formula in the CNF form in a specific format. If it is possible to accept some of the proposals and decline all the others while satisfying all the constraints, the formula must be satisfiable. Otherwise, the formula must be unsatisfiable. The number of variables in the formula must not exceed 3000, and the number of clauses must not exceed 5000. 
On the first line, output integers *C* and *V* — the number of clauses in the formula and the number of variables respectively. On each of the next *C* lines, output a description of a single clause. Each clause has a form (*x_4* OR !*x_1* OR *x_8*). For a clause with k terms (in the example, k = 3 for *x_4*, *x_1* and *x_8*), output first those *k* terms and then number 0 in the end (in the example, output “4 − 1 8 0”). Output each term as integer number. Output variables *x_1*, *x_2*, . . . , *x_V* as numbers 1, 2, . . . , V respectively. Output negations of variables *x_1*, *x_2*, . . . , *x_V* as numbers −1, −2, . . . , −V respectively. Each number other than the last one in each line must be a non-zero integer between −*V* and *V* where *V* is the total number of variables specified in the first line of the output. Ensure that 1 ≤ *C* ≤ 5000 and 1 ≤ *V* ≤ 3000.

## 4-1. Integrated Circuit Design.
*In this problem, you will determine how to connect the modules of an integrated circuit with wires so that all the wires can be routed on the same layer of the circuit.*

**Task.** VLSI or Very Large-Scale Integration is a process of creating an integrated circuit by combining thousands of transistors on a single chip. You want to design a single layer of an integrated circuit. You know exactly what modules will be used in this layer, and which of them should be connected by wires. The wires will be all on the same layer, but they cannot intersect with each other. Also, each wire can only be bent once, in one of two directions — to the left or to the right. If you connect two modules with a wire, selecting the direction of bending uniquely defines the position of the wire. Of course, some positions of some pairs of wires lead to intersection of the wires, which is forbidden. You
need to determine a position for each wire in such a way that no wires intersect.
This problem can be reduced to 2-SAT problem — a special case of the SAT problem in which each clause contains exactly 2 variables. For each wire 𝑖, denote by 𝑥𝑖 a binary variable which takes value 1 if the wire is bent to the right and 0 if the wire is bent to the left. For each 𝑖, 𝑥𝑖 must be either 0 or 1. Also, some pairs of wires intersect in some positions. For example, it could be so that if wire 1 is bent to the left and wire 2 is bent to the right, then they intersect. We want to write down a formula which is satisfied only if no wires intersect. In this case, we will add the clause (𝑥1 𝑂𝑅 𝑥2) to the formula which ensures that either 𝑥1 (the first wire is bent to the right) is true or 𝑥2 (the second wire is bent to the left) is true, and so the particular crossing when wire 1 is bent to the left AND wire 2 is bent to the right doesn’t happen whenever the formula is satisfied. We will add such a clause for each pair of wires and each pair of their positions if they intersect when put in those positions. Of course, if some pair of wires intersects in any pair of possible positions, we won’t be able to design a circuit. Your task is to determine whether it is possible, and if yes, determine the direction of bending for each of the wires.

**Input:** The input represents a 2-CNF formula. The first line contains two integers 𝑉 and 𝐶 — the number of variables and the number of clauses respectively. Each of the next 𝐶 lines contains two non-zero integers 𝑖 and 𝑗 representing a clause in the CNF form. If 𝑖 > 0, it represents 𝑥𝑖 , otherwise if 𝑖 < 0, it represents 𝑥−𝑖 , and the same goes for 𝑗. For example, a line “2 3” represents a clause (𝑥2 𝑂𝑅 𝑥3), line “1 -4” represents (𝑥1 𝑂𝑅 𝑥4), line “-1 -3” represents (𝑥1 𝑂𝑅 𝑥3), and line “0 2” cannot happen, because 𝑖 and 𝑗 must be non-zero.

**Output:** If the 2-CNF formula in the input is unsatisfiable, output just the word “UNSATISFIABLE” (without quotes, using capital letters). If the 2-CNF formula in the input is satisfiable, output the word “SATISFIABLE” (without quotes, using capital letters) on the first line and the corresponding assignment of variables on the second line. For each 𝑥𝑖 in order from 𝑥1 to 𝑥𝑉 , output 𝑖 if 𝑥𝑖 = 1 or −𝑖 if 𝑥𝑖 = 0. For example, if a formula is satisfied by assignment 𝑥1 = 0, 𝑥2 = 1, 𝑥3 = 0, 3 output “-1 2 -3” on the second line (without quotes). If there are several possible assignments satisfying the input formula, output any one of them.

## 4-2. Plan a Fun Party.
*You’re planning a company party. You’d like to invite the coolest people, and you’ve assigned each one of them a fun factor — the more the fun factor, the cooler is the person. You want to maximize the total fun factor (sum of the fun factors of all the invited people). However, you can’t invite everyone, because if the direct boss of some invited person is also invited, it will be awkward. Find out what is the maximum possible total fun factor.*

**Input:** The first line contains an integer 𝑛 — the number of people in the company. The next line contains 𝑛 numbers 𝑓𝑖 — the fun factors of each of the 𝑛 people in the company. Each of the next 𝑛−1 lines describes the subordination structure. Everyone but for the CEO of the company has exactly one direct boss. There are no cycles: nobody can be a boss of a boss of a ... of a boss of himself. So, the subordination structure is a regular tree. Each of the 𝑛 − 1 lines contains two integers 𝑢 and 𝑣, and you know that either 𝑢 is the boss of 𝑣 or vice versa (you don’t really need to know which one is the boss, but you can invite only one of them or none of them).

**Output:** Output the maximum possible total fun factor of the party (the sum of fun factors of all the invited people).

## 4-3. School Bus
*A school bus needs to start from the depot early in the morning, pick up all the children from their homes in some order, get them all to school and return to the depot. You know the time it takes to get from depot to each home, from each home to each other home, from each home to the school and from the school to the depot. You want to define the order in which to visit children’s homes so as to
minimize the total time spent on the route. This is an instance of a classical NP-complete problem called Traveling Salesman Problem. Given a graph with weighted edges, you need to find the shortest cycle visiting each vertex exactly once. Vertices correspond to homes, the school and the depot. Edges weights correspond to the time to get from one vertex to another one. Some vertices may not be connected by an edge in the general case.*

**Input:** The first line contains two integers 𝑛 and 𝑚 — the number of vertices and the number of edges in the graph. The vertices are numbered from 1 through 𝑛. Each of the next 𝑚 lines contains three integers 𝑢, 𝑣 and 𝑡 representing an edge of the graph. This edge connects vertices 𝑢 and 𝑣, and it takes time 𝑡 to get from 𝑢 to 𝑣. The edges are bidirectional: you can go both from 𝑢 to 𝑣 and from𝑣 to 𝑢 in time 𝑡 using this edge. No edge connects a vertex to itself. No two vertices are connected by more than one edge.

**Output:** If it is possible to start in some vertex, visit each other vertex exactly once in some order going by edges of the graph and return to the starting vertex, output two lines. On the first line, output the minimum possible time to go through such circular route visiting all vertices exactly once (apart from the first vertex which is visited twice — in the beginning and in the end). On the second line, output the order in which you should visit the vertices to get the minimum possible time on the route. That is, output the numbers from 1 through 𝑛 in the order corresponding to visiting the vertices. Don’t output the starting vertex second time. However, account for the time to get from the last vertex back to the starting vertex. If there are several solutions, output any one of them. If there is no such circular route, output just −1 on a single line. Note that for 𝑛 = 2 it is considered a correct circular route to go from one vertex to another by an edge and then return back by the same edge.

## 4-4. Reschedule the Exams.
*Implement an efficient algorithm to reschedule the exams in such a way that every student can come to the exam she is assigned to, and no two friends will be passing the exam the same day.*

Task. The new secretary at your Computer Science Department has prepared a schedule of exams for CS101: each student was assigned to his own exam date. However, it’s a disaster: not only some pairs of students known to be close friends may have been assigned the same date, but also NONE of the students can actually come to the exam at the day they were assigned (there was a misunderstanding between the secretary who asked to specify available dates and the students who understood they needed to select the date at which they cannot come). There are three different dates the professors are available for these exams, and these dates cannot be changed. The only thing that can be changed is the assignment of students to the dates of exams. You know for sure that each student can’t come at the currently scheduled date, but also each student definitely can come at any of the two other possible dates. Also, you must make sure that no two known close friends are assigned to the same exam date. You need to determine whether it is possible or not, and if yes, suggest a specific assignment of the students to the dates.
This problem can be reduced to a graph problem called 3-recoloring. You are given a graph, and each vertex is colored in one of the 3 possible colors. You need to assign another color to each vertex in such a way that no two vertices connected by and edge are assigned the same color. Here, possible colors correspond to the possible exam dates, vertices correspond to students, colors of the vertices correspond to the assignment of students to the exam dates, and edges correspond to the pairs of close friends.

**Input:**. The first line contains two integers 𝑛 and 𝑚 — the number of vertices and the number of edges of the graph. The vertices are numbered from 1 through 𝑛. The next line contains a string of length 𝑛 consisting only of letters 𝑅, 𝐺 and 𝐵 representing the current color assignments. For each position 𝑖 (1-based) in the string, if it is 𝑅, then the vertex 𝑖 is colored red; if it’s 𝐺, the vertex 𝑖 is colored green; if it’s 𝐵, the vertex 𝑖 is colored blue. These are the current color assignments, and each of them must be changed. Each of the next 𝑚 lines contains two integers 𝑢 and 𝑣 — vertices 𝑢 and 𝑣 are connected by an edge (it is possible that 𝑢 = 𝑣).

**Output:** If it is impossible to reassign the students to the dates of exams in such a way that no two friends are going to pass the exam the same day, and each student’s assigned date has changed, output just one word “Impossible” (without quotes). Otherwise, output one string consisting of 𝑛 characters 𝑅, 𝐺 and 𝐵 representing the new coloring of the vertices. Note that the color of each vertex must be 11 different from the initial color of this vertex. The vertices connected by an edge must have different colors
