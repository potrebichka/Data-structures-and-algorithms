## 1-1. Evacuating People.
*An algorithm for finding maximum flow in a network to determine how fast people can be evacuated from the given city.*

**Input:** The first line of the input contains integers n and m — the number of cities and the number of roads respectively. Each of the next m lines contains three integers u, v and c describing a particular road — start of the road, end of the road and the number of people that can be transported through this road in one hour. u and v are the 1-based indices of the corresponding cities.
The city from which people are evacuating is the city number 1, and the capital city is the city number n.

**Output:** The maximum number of people that can be evacuated from the city nu,ber 1 each hour.

## 1-2. Assigning Airline Crews to Flights.
*The airline offers a bunch of flights and has a set of crews that can work on those flights. However, the flights are starting in different cities and at different times, so only some of the crews are able to work on a particular flight. You are given the pairs of flights and associated crews that can work on those flights. You need to assign crews to as many flights as possible and output all the assignments.* An Algorithm for finding maximum matching in bipartite graph to assign airline crews to flights in the most efficient way.

**Input:** The first line of the input contains integers n and m — the number of flights and the number of crews respectively. Each of the next n lines contains m binary integers (0 or 1). If the j-th integer in the i-th line is 1, then the crew number j can work on the flight number i, and if it is 0, then it cannot.

**Output**: Output n integers — for each flight, output the 1-based index of the crew assigned to this flight. If no crew is assigned to a flight, output −1 as the index of the crew corresponding to it. All the positive indices in the output must be between 1 and m, and they must be pairwise different, but you can output any number of −1’s. If there are several assignments with the maximum possible number of flights having a crew assigned, output any of them.

## 1-3. Stock Charts.
*Find the most compact way of visualising stock price data using charts.*
You’re in the middle of writing your newspaper’s end-of-year economics summary, and you’ve decided that you want to show a number of charts to demonstrate how different stocks have performed over the course of the last year. You’ve already decided that you want to show the price of n different stocks, all at the same k points of the year. A simple chart of one stock’s price would draw lines between the points (0, price_0),(1, price_1), . . . ,(k − 1, price_k−1), where price_i is the price of the stock at the i-th point in time. In order to save space, you have invented the concept of an overlaid chart. An overlaid chart is the
combination of one or more simple charts, and shows the prices of multiple stocks (simply drawing a line for each one). In order to avoid confusion between the stocks shown in a chart, the lines in an overlaid chart may not cross or touch.
Given a list of n stocks’ prices at each of k time points, determine the minimum number of overlaid charts you need to show all of the stocks’ prices

**Input:** The first line of the input contains two integers n and k — the number of stocks and the number of points in the year which are common for all of them. Each of the next n lines contains k integers. The i-th of those n lines contains the prices of the i-th stock at the corresponding k points in the year.

**Output:**The minimum number of overlaid charts to visualize all the stock price data you have.

## 2-1. Ingfer Energy Values of Ingredients
*Apply Gaussian Elimination to infer the energy values of ingredients given a restaurant menu with calorie counts and ingredient lists provided for each item.
You’re looking into a restaurant menu which shows for each dish the list of ingredients with amounts and the estimated total energy value in calories. You would like to find out the energy values of individual ingredients (then you will be able to estimate the total energy values of your favorite dishes).*

**Input:** The first line of the input contains an integer n — the number of dishes in the menu, and it happens so that the number of different ingredients is the same. Each of the next n lines contains description a_1, a_2, . . . , a_n, E of a single menu item. a_i is the amount of i-th ingredient in the dish, and E is the estimated total energy value of the dish. If the ingredient is not used in the dish, the amount will be specified as a_i = 0; beware that although the amount of any ingredient in any real menu would be positive, we will test that your algorithm works even for negative amounts a_i < 0.

**Output**: n real numbers — for each ingredient, what is its energy value. These numbers can be non-integer, so output them with at least 3 digits after the decimal point.

## 2-2. Optimal Diet Problem
*Implement an algorithm for solving linear programming with only a few inequalities and apply it to determine the optimal diet.*

**Input:** The first line of the input contains integers n and m — the number of restrictions on your diet and the number of all available dishes and drinks respectively. The next n + 1 lines contain the coefficients of the linear inequalities in the standard form Ax ≤ b, where x = amount is the vector of length m with amounts of each ingredient, A is the n × m matrix with coefficients of inequalities and b is the vector with the right-hand side of each inequality. Specifically, i-th of the next n lines contains m integers A_i1, A_i2, . . . , A_im, and the next line after those n contains n integers b_1, b_2, . . . , b_n. These lines describe n inequalities of the form A_i1 · amount1 + A_i2 · amount2 + · · · + A_im · amount_m ≤ b_i. The last line of the input contains m integers — the pleasure for consuming one item of each dish and drink pleasure_1, pleasure_2, . . . , pleasure_m.

**Output:** If there is no diet that satisfies all the restrictions, output “No solution” (without quotes). If you can get as much pleasure as you want despite all the restrictions, output “Infinity” (without quotes). If the maximum possible total pleasure is bounded, output two lines. On the first line, output “Bounded solution” (without quotes). On the second line, output m real numbers — the optimal amounts for each dish and drink. Output all the numbers with at least 15 digits after the decimal point.

## 3-1. Assign Frequencies to the Cells of a GSM Network.
*This is equivalent to a classical graph coloring problem: in other words, you are given a graph, and you need to color its vertices into 3 different colors, so that any two vertices connected by an edge need to be of different colors. Colors correspond to frequencies, vertices correspond to cells, and edges connect neighboring cells. Graph coloring is an NP-complete problem, so we don’t currently know an efficient solution to it, and you need to reduce it to an instance of SAT problem which, although it is NP-complete, can often be solved efficiently in practice using special programs called SAT-solvers.*

**Input:** The first line of the input contains integers n and m — the number of vertices and edges in the graph. The vertices are numbered from 1 through n. Each of the next m lines contains two integers u and v — the numbers of vertices connected by an edge. It is guaranteed that a vertex cannot be connected to itself by an edge.

**Output**: You need to output a boolean formula in the conjunctive normal form (CNF) in a specific format. If it is possible to color the vertices of the input graph in 3 colors such that any two vertices connected by an edge are of different colors, the formula must be satisfiable. Otherwise, the formula must be unsatisfiable. The number of variables in the formula must be at least 1 and at most 3000. The number of clauses must be at least 1 and at most 5000. On the first line, output integers c and v — the number of clauses in the formula and the number of variables respectively. On each of the next c lines, output a description of a single clause. Each clause has a form (x_4 OR x_1 OR x_8). For a clause with k terms (in the example, k = 3 for x_4, x_1 and x_8), output first those k terms and then number 0 in the end (in the example, output “4 − 1 8 0”). Output each term as integer number. Output variables x_1, x_2, . . . , x_v as numbers 1, 2, . . . , v respectively. Output 3 negations of variables x_1, x_2, . . . , x_v as numbers −1, −2, . . . , −v respectively. Each number other than the last one in each line must be a non-zero integer between −v and v where v is the total number of variables specified in the first line of the output. Ensure that 1 ≤ c ≤ 5000 and 1 ≤ v ≤ 3000. If there are many different formulas that satisfy the requirements above, you can output any one of them.

## 3-2. Cleaning the Apartment.
*You’ve just had a huge party in your parents’ house, and they are returning tomorrow. You need to not only clean the apartment, but leave no trace of the party. To do that, you need to clean all the rooms in some order. After finishing a thorough cleaning of some room, you cannot return to it anymore: you are afraid you’ll ruin everything accidentally and will have to start over. So, you need to
move from room to room, visit each room exactly once and clean it. You can only move from a room to the neighboring rooms. You want to determine whether this is possible at all. This can be reduced to a classic Hamiltonian Path problem: given a graph, determine whether there is a route visiting each vertex exactly once. Rooms are vertices of the graph, and neighboring rooms are connected by edges. Hamiltonian Path problem is NP-complete, so we don’t know an efficient algorithm to solve it. You need to reduce it to SAT, so that it can be solved efficiently by a SAT-solver.*

**Input:** The first line contains two integers n and m — the number of rooms and the number of corridors connecting the rooms respectively. Each of the next m lines contains two integers u and v describing the corridor going from room u to room v. The corridors are two-way, that is, you can go both from u to v and from v to u. No two corridors have a common part, that is, every corridor only allows you to go from one room to one other room. Of course, no corridor connects a room to itself. Note that a corridor from u to v can be listed several times, and there can be listed both a corridor from u to v and a corridor from v to u.

**Output:** You need to output a boolean formula in the CNF form in a specific format. If it is possible to go through all the rooms and visit each one exactly once to clean it, the formula must be satisfiable. Otherwise, the formula must be unsatisfiable. The sum of the numbers of variables used in each clause of the formula must not exceed 120 000. On the first line, output integers c and v — the number of clauses in the formula and the number of variables respectively. On each of the next c lines, output a description of a single clause. Each clause has a form (x_4 OR x_1 OR x_8). For a clause with k terms (in the example, k = 3 for x_4, x_1 and x_8), output first those k terms and then number 0 in the end (in the example, output “4 − 1 8 0”). Output each term as integer number. Output variables x_1, x_2, . . . , x_v as numbers 1, 2, . . . , v respectively. Output negations of variables x_1, x_2, . . . , x_v as numbers −1, −2, . . . , −v respectively. Each number other than the last one in each line must be a non-zero integer between −v and v where v is the total number of variables specified in the first line of the output. Ensure that the total number of non-zero integers in the c lines describing the clauses is at most 120 000.

## 3-3. Advertisement Budget Allocation.
*In this programming assignment, you’ll work for a big company that uses advertising to promote itself. You will need to determine whether it is possible to allocate advertising budget and satisfy all the constraints. You will learn how to reduce this problem to a particular type of Integer Linear Programming problem. Then you will design and implement an efficient algorithm to reduce this type of Integer Linear Programming to SAT.*


Task. The marketing department of your big company has many subdepartments which control advertising on TV, radio, web search, contextual advertising, mobile advertising, etc. Each of them has prepared their advertising campaign plan, and of course you don’t have enough budget to cover all of their proposals. You don’t have enough time to go thoroughly through each subdepartment’s proposals and cut them, because you need to set the budget for the next year tomorrow. You decide that you will either approve or decline each of the proposals as a whole. There is a bunch of constraints you face. For example, your total advertising budget is limited. Also, you have some contracts with advertising agencies for some of the advertisement types that oblige you to spend at least some fixed budget on that kind of advertising, or you’ll see huge penalties, so you’d better spend it. Also, there are different company policies that can be of the form that you spend at least 10% of your total advertising spend on mobile advertising to promote yourself in this new channel, or that you spend at least $1M a month on TV advertisement, so that people always remember your brand. All of these constraints can be rewritten as an Integer Linear Programming: for each subdepartment i, denote by x_i boolean variable that corresponds to whether you will accept or decline the proposal of that subdepartment. Then each constraint can be written as a linear inequality.
For example, *E*(n, i=1) *spend_i* * *x_i* ≤ TotalBudget is the inequality to ensure your total budget is enough to accept all the selected proposals. And *E*(n, i=1) *spend_i* · *x_i* ≤ 10 · *mobile* corresponds to the fact that mobile advertisement budget is at least 10% of the total spending. You will be given the final Integer Linear Programming problem in the input, and you will need to reduce it to SAT. It is guaranteed that there will be at most 3 different variables with non-zero coefficients in each inequality of this Integer Linear Programming problem.

**Input:** The first line contains two integers n and m — the number of inequalities and the number of variables. The next *n* lines contain the description of *n*×*m* matrix *A* with coefficients of inequalities (each of the *n* lines contains *m* integers, and at most 3 of them are non-zero), and the last line contains the description of the vector *b* (*n* integers) for the system of inequalities *Ax* ≤ *b*. You need to determine whether there exists a binary vector *x* satisfying all those inequalities.

**Output:** You need to output a boolean formula in the CNF form in a specific format. If it is possible to accept some of the proposals and decline all the others while satisfying all the constraints, the formula must be satisfiable. Otherwise, the formula must be unsatisfiable. The number of variables in the formula must not exceed 3000, and the number of clauses must not exceed 5000. 
On the first line, output integers *C* and *V* — the number of clauses in the formula and the number of variables respectively. On each of the next *C* lines, output a description of a single clause. Each clause has a form (*x_4* OR !*x_1* OR *x_8*). For a clause with k terms (in the example, k = 3 for *x_4*, *x_1* and *x_8*), output first those *k* terms and then number 0 in the end (in the example, output “4 − 1 8 0”). Output each term as integer number. Output variables *x_1*, *x_2*, . . . , *x_V* as numbers 1, 2, . . . , V respectively. Output negations of variables *x_1*, *x_2*, . . . , *x_V* as numbers −1, −2, . . . , −V respectively. Each number other than the last one in each line must be a non-zero integer between −*V* and *V* where *V* is the total number of variables specified in the first line of the output. Ensure that 1 ≤ *C* ≤ 5000 and 1 ≤ *V* ≤ 3000.
